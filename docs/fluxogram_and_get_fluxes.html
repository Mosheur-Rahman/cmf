<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cmf: How to get a nice visual representation of your model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cmf-logo-klein.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
  <div id="projectnumber">2.0.0a0</div>
   <div id="projectbrief">The Catchment Modelling Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('fluxogram_and_get_fluxes.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How to get a nice visual representation of your model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Downloads</h2>
<ul>
<li><a href="http://fb09-pasig.umwelt.uni-giessen.de:8081/datafiles/user/florian/Tutorials/fluxogram.py">Fluxogram</a></li>
<li><a href="http://fb09-pasig.umwelt.uni-giessen.de:8081/datafiles/user/florian/Tutorials/get_storages_fluxes.py">Get storages and fluxes</a></li>
</ul>
<h2>Introduction</h2>
<p>As your lumped model gets more and more complex it sometimes is difficult to not lose the overview in your own model. This tutorial will show you how to find out where the water in your model is stored and what its flowpaths are. Additionally you will learn how to make a nice graphic (a fluxogram) out of the data you get. One example for a bit more complex fluxogram can be seen <a href="https://youtu.be/cP0PfDpfW88">here</a>.</p>
<h2>Building a simple and lumped CMF model</h2>
<p>The first step we need to tackle is to construct a small CMF Model which we will explore in later steps. By now you should be familiar with simple setups like this. To be able to work your model file and the files for the fluxogram and get_storages_fluxes all need to be in the same directory.</p>
<p>~~~~~~~~~~~{.py} </p><h1>first import a few handy tools</h1>
<p>import numpy as np import cmf import datetime</p>
<h1>also import the fluxogram and our function to find the fluxes and storages</h1>
<p>import fluxogram import get_storages_fluxes as gsf</p>
<h1>create the project and cell for the lumped model</h1>
<p>p = <a class="el" href="classcmf_1_1project.html" title="The study area, holding all cells, outlets and streams. ">cmf.project()</a> c = p.NewCell(0,0,0,1000)</p>
<h1>create the storages and the outlet they flow to</h1>
<p>c.surfacewater_as_storage() c.add_layer(5.0) outlet = p.NewOutlet("outlet",10,0,0)</p>
<h1>add the connections between the storages</h1>
<p>cmf.kinematic_wave(c.surfacewater, outlet, 1) cmf.kinematic_wave(c.surfacewater, c.layers[0], 1) cmf.kinematic_wave(c.layers[0], outlet, 3) <br />
 </p><h1>define the timeperiod of the model</h1>
<p>begin = datetime.datetime(1979,1,1) end = begin + 15 * datetime.timedelta(days = 1) step = datetime.timedelta(days=1)</p>
<h1>create artificial rain data</h1>
<p>Prec = cmf.timeseries(begin, step) Prec.extend(prec for prec in np.random.randint(0, high = 30, size = 15))</p>
<h1>add a rainstation and tell the model to use it</h1>
<p>rainstation = p.rainfall_stations.add("Rain", Prec, (0,0,0)) p.use_nearest_rainfall() ~~~~~~~~~~~~~~~</p>
<h2>Creating a solver and letting the model run, while collecting the data</h2>
<p>As we now have a model to explore, we can make it run by using a solver that calculates our fluxes and storages. While the model is running we also collect the fluxes and storages for every single day seperately. For this we use get_storages_fluxes.py. In this file are functions that go recursively through all nodes of the model and collect the data. For simple usage it is not neccesary to understand exactly how it works, but it sure does not hurt to try. If you cannot grasp it, do not be dissapointed. You can practice the leap of faith.</p>
<div class="fragment"><div class="line"><span class="comment"># create a solver</span></div><div class="line">solver = cmf.CVodeIntegrator(p, 1e-8)</div><div class="line"></div><div class="line"><span class="comment"># create empty lists to store the results of the fluxes and storages later</span></div><div class="line">timeseries_fluxes = [] timeseries_storages = []</div><div class="line"></div><div class="line"><span class="comment"># let the solver run for our timeperiod in one day steps</span></div><div class="line"><span class="keywordflow">for</span> t <span class="keywordflow">in</span> solver.run(begin, end, cmf.day):</div><div class="line">    <span class="comment"># the fluxes are at first returned in a very detailed way</span></div><div class="line">    <span class="comment"># as this can be a bit overwhelming we convert them to a version</span></div><div class="line">    <span class="comment"># that is easier to use</span></div><div class="line">    fluxes_raw = gsf.flux_of_all_nodes_of_cell(c.rain_source, c, t)</div><div class="line">    <span class="comment"># the following function is used for this conversion</span></div><div class="line">    fluxes_nicer = gsf.convert_fluxes_for_fluxogram(fluxes_raw)</div><div class="line">    <span class="comment"># add the fluxes and storages to our timeseries</span></div><div class="line">    timeseries_fluxes.append(fluxes_nicer)</div><div class="line">    timeseries_storages.append(gsf.storages_of_cell(c.rain_source, c))</div></div><!-- fragment --><h2>Clean and display the data</h2>
<p>After we now have collected data for the fluxes and storages on every day our model run we can display it. But before this we have to clean it of artifacts.</p>
<div class="fragment"><div class="line"><span class="comment"># due to the way CMF constructs models and how this program searches </span></div><div class="line"><span class="comment"># through it, nodes with no fluxes and storage can occur.</span></div><div class="line"><span class="comment"># To get rid of them the following function can be useful</span></div><div class="line"><span class="comment"># but be careful as sometimes those empty timeseries emerge because</span></div><div class="line"><span class="comment"># you did something wrong and not the code          </span></div><div class="line">timeseries_fluxes_stripped = gsf.del_empty_nodes(timeseries_fluxes)</div><div class="line">timeseries_storages_stripped = gsf.del_empty_nodes(timeseries_storages)</div><div class="line"></div><div class="line"><span class="comment"># and now lets look on the results</span></div><div class="line"><span class="keywordflow">for</span> day, day_counter <span class="keywordflow">in</span> zip(timeseries_storages_stripped, range(len(</div><div class="line">                                        timeseries_storages_stripped))):</div><div class="line">    print(<span class="stringliteral">&quot;Storages volumes on day: &quot;</span> + str(day_counter))       </div><div class="line">    print(day)</div><div class="line">    print(<span class="stringliteral">&quot;&quot;</span>)</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> day, day_counter <span class="keywordflow">in</span> zip(timeseries_fluxes_stripped, range(len(</div><div class="line">                                            timeseries_fluxes_stripped))):</div><div class="line">    print(<span class="stringliteral">&quot;Fluxes volumes on day: &quot;</span> + str(day_counter))       </div><div class="line">    print(day)</div><div class="line">    print(<span class="stringliteral">&quot;&quot;</span>)</div></div><!-- fragment --><h2>Getting ready to make a fluxogram</h2>
<p>The fluxogram is animated from a bunch of single pictures that get stitched together. For this stitching we need ffmpeg. ffmpeg is a handy project to handle video and audio material. It can be downloaded ​here. To be able to use it correctly ffmpeg also needs to be added to your systems PATH. PATH is a variable your computer searches through if you try to call programs from the console. An explanation how to do this can be found ​here. You can test if you have done it right if you open a console and type "ffmpeg". If it does not throw an error and shows you the options of ffmpeg you have done everything right. If it does not work directly try restarting your computer.</p>
<h2>Building a fluxogram</h2>
<p>After we now have the data from our model and the additional programs we need, we can make a fluxogram.</p>
<p>~~~~~~~~~~~{.py} </p><h1>first create an instance of the fluxogram object</h1>
<h1>To work properly the fluxogram needs to know a few things from you</h1>
<h1>The first number is the maximal flow that will occur in your model.</h1>
<h1>You do not need the exact number, just a rough estimate</h1>
<h1>This holds also true for the second number which is your maximal</h1>
<h1>storage volume. The grid_size defines how big your fluxogram will be</h1>
<h1>and root = True is needed if your data differs wildly in size.</h1>
<h1>In this case root = True will smooth things out.</h1>
<p>fl = fluxogram.Fluxogram(30, 50, grid_size = 10, root = True)</p>
<h1>After we now have a fluxogram instance to work with we can add the storages</h1>
<h1>and fluxes. But as the order must be the same as the order of our data.</h1>
<h1>Therefore, we first have to find out what the order of our data is</h1>
<h1>and shape our fluxogram accordingly. The following lines can be commented</h1>
<h1>out, once the order of the data is known</h1>
<p>print(sorted(timeseries_fluxes_stripped[0].keys())) print(sorted(timeseries_storages_stripped[0].keys())) ~~~~~~~~~~~~~ Now we know our model is sorted. In this case the fluxes are sorted like:</p>
<p>1) Layer0 to outlet 2) rainfall to surfacewater 3) surfacewater to layer0 4) surfacewater to outlet</p>
<p>while the storages are sorted like:</p>
<p>1) Layer0 2) surfacewater</p>
<p>With this information we can build our fluxogram. But first a little note on what the structure of a fluxogram is. In a fluxogram every storage has an order and an offset. In <a href="https://postimg.org/image/3p6n3aar9/">this</a> image you can see how the fluxogram is sorted using order and offset. So when you create a storage in a fluxogram you have to have an idea on how your fluxogram should look and set order and offset accordingly.</p>
<p>~~~~~~~~~~~{.py} </p><h1>to add storages we have to give them some input as well</h1>
<h1>the sequence is (name_of_storage, starting volume, order, offset)</h1>
<p>fl.add_storage("Layer0", 50, 2, 0) fl.add_storage("Surfacewater", 50, 1, 0)</p>
<h1>Those were the storages we have a volume for. But our water</h1>
<h1>is also coming from the rain source and goint to the outlet</h1>
<h1>Therefore, we have to add those things as storages as well</h1>
<p>fl.add_storage("Rain", 0, 0, 0) fl.add_storage("Outlet", 0, 2, 1)</p>
<h1>The next step is to add the fluxes between the storages we have</h1>
<h1>just created. A flux needs to know what its name is, where it is</h1>
<h1>coming from, where it is going to and what its starting volume ist</h1>
<p>fl.add_flux("lay0_out", fl.storages[0], fl.storages[3], 30) fl.add_flux("rain_surf", fl.storages[2], fl.storages[1], 30) fl.add_flux("surf_lay0", fl.storages[1], fl.storages[0], 30) fl.add_flux("surf_out", fl.storages[1], fl.storages[3], 30)</p>
<h1>now our fluxogram is complete and we can display it</h1>
<p>fl.draw() fl.show() ~~~~~~~~~~~~~~~~~</p>
<h2>Animating a fluxogram</h2>
<p>After we now have a complete fluxogram and all the data we need the animation is easy. Their is just one thing you should know: The animation function uses the windows console. If you use Linux or Mac you have to edit the fluxogram animation method yourselve.</p>
<div class="fragment"><div class="line">fl.animate(timeseries_fluxes_stripped, timeseries_storages_stripped, <span class="stringliteral">&quot;name_video&quot;</span>)</div></div><!-- fragment --><p>Now you have to wait until the fluxogram animation is ready. During the process a lot of pictures of the model will be created in your working directory. But do not worry, the fluxogram will delete all of them once it has finished the animation. Your result should look something like <a href="https://youtu.be/URAnH_ILzJk">this</a>. Have fun </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<hr class="footer"/><address class="footer"><small>
<div>&copy 2008-2017 by 
<a class="el" href="http://www.uni-giessen.de/hydro/kraft"> Philipp Kraft</a> and
<a class="el" href="http://www.uni-giessen.de/hydro"> 
Institute of Landscape Ecology and Resources Management,University of Gie&szlig;en</a>
</h3></td>
<td>Generated: Tue Mar 12 2019 14:35:48</td>
</tr></table>
</small></address>
</body>
</html>
